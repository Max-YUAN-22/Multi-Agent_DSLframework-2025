{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef, useCallback } from 'react';\nconst useWebSocket = url => {\n  _s();\n  const [messages, setMessages] = useState([]);\n  const [readyState, setReadyState] = useState(WebSocket.CLOSED);\n  const ws = useRef(null);\n  const mounted = useRef(false);\n  useEffect(() => {\n    mounted.current = true;\n    const connect = () => {\n      // Ensure we don't create a new connection if one is already open or connecting\n      if (ws.current && (ws.current.readyState === WebSocket.OPEN || ws.current.readyState === WebSocket.CONNECTING)) {\n        return;\n      }\n      ws.current = new WebSocket(url);\n      ws.current.onopen = () => {\n        console.log('WebSocket Connected');\n        setReadyState(WebSocket.OPEN);\n      };\n      ws.current.onmessage = event => {\n        const message = JSON.parse(event.data);\n        if (message.type === 'ping') {\n          ws.current.send(JSON.stringify({\n            type: 'pong'\n          }));\n        } else {\n          setMessages(prevMessages => [...prevMessages, message]);\n        }\n      };\n      ws.current.onclose = () => {\n        console.log('WebSocket Disconnected');\n        setReadyState(WebSocket.CLOSED);\n        // Attempt to reconnect only if the component is still mounted\n        if (mounted.current) {\n          setTimeout(connect, 5000);\n        }\n      };\n      ws.current.onerror = error => {\n        console.error('WebSocket Error:', error);\n        setReadyState(WebSocket.CLOSED);\n        // Optionally close the socket on error to trigger the onclose reconnect logic\n        ws.current.close();\n      };\n    };\n    connect();\n    return () => {\n      mounted.current = false;\n      if (ws.current) {\n        ws.current.close();\n      }\n    };\n  }, [url]);\n  const sendMessage = useCallback((type, data) => {\n    if (ws.current && ws.current.readyState === WebSocket.OPEN) {\n      const message = JSON.stringify({\n        type,\n        data\n      });\n      ws.current.send(message);\n    } else {\n      console.error('WebSocket is not connected.');\n    }\n  }, []);\n  const sendGenerateReport = useCallback(() => {\n    sendMessage('generate_report');\n  }, [sendMessage]);\n  const clearHistory = useCallback(() => {\n    setMessages([]);\n  }, []);\n  return {\n    messages,\n    readyState,\n    sendMessage,\n    sendGenerateReport,\n    clearHistory\n  };\n};\n_s(useWebSocket, \"na4GwWISTO6iTX0q74oyVF0Eehk=\");\nexport default useWebSocket;","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","useWebSocket","url","_s","messages","setMessages","readyState","setReadyState","WebSocket","CLOSED","ws","mounted","current","connect","OPEN","CONNECTING","onopen","console","log","onmessage","event","message","JSON","parse","data","type","send","stringify","prevMessages","onclose","setTimeout","onerror","error","close","sendMessage","sendGenerateReport","clearHistory"],"sources":["/Users/Apple/Desktop/multi-agent-dsl-final/frontend/src/hooks/useWebSocket.js"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from 'react';\n\nconst useWebSocket = (url) => {\n  const [messages, setMessages] = useState([]);\n  const [readyState, setReadyState] = useState(WebSocket.CLOSED);\n  const ws = useRef(null);\n  const mounted = useRef(false);\n\n  useEffect(() => {\n    mounted.current = true;\n    const connect = () => {\n      // Ensure we don't create a new connection if one is already open or connecting\n      if (ws.current && (ws.current.readyState === WebSocket.OPEN || ws.current.readyState === WebSocket.CONNECTING)) {\n        return;\n      }\n\n      ws.current = new WebSocket(url);\n      ws.current.onopen = () => {\n        console.log('WebSocket Connected');\n        setReadyState(WebSocket.OPEN);\n      };\n\n      ws.current.onmessage = (event) => {\n        const message = JSON.parse(event.data);\n        if (message.type === 'ping') {\n          ws.current.send(JSON.stringify({ type: 'pong' }));\n        } else {\n          setMessages((prevMessages) => [...prevMessages, message]);\n        }\n      };\n\n      ws.current.onclose = () => {\n        console.log('WebSocket Disconnected');\n        setReadyState(WebSocket.CLOSED);\n        // Attempt to reconnect only if the component is still mounted\n        if (mounted.current) {\n          setTimeout(connect, 5000);\n        }\n      };\n\n      ws.current.onerror = (error) => {\n        console.error('WebSocket Error:', error);\n        setReadyState(WebSocket.CLOSED);\n        // Optionally close the socket on error to trigger the onclose reconnect logic\n        ws.current.close();\n      };\n    };\n\n    connect();\n\n    return () => {\n      mounted.current = false;\n      if (ws.current) {\n        ws.current.close();\n      }\n    };\n  }, [url]);\n\n  const sendMessage = useCallback((type, data) => {\n    if (ws.current && ws.current.readyState === WebSocket.OPEN) {\n      const message = JSON.stringify({ type, data });\n      ws.current.send(message);\n    } else {\n      console.error('WebSocket is not connected.');\n    }\n  }, []);\n\n  const sendGenerateReport = useCallback(() => {\n    sendMessage('generate_report');\n  }, [sendMessage]);\n\n  const clearHistory = useCallback(() => {\n    setMessages([]);\n  }, []);\n\n  return { messages, readyState, sendMessage, sendGenerateReport, clearHistory };\n};\n\nexport default useWebSocket;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}